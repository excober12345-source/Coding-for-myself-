"""
ai_trader.py
Simple, safe trading bot skeleton:
 - SMA crossover strategy
 - Backtest on historical OHLCV
 - Paper trading executor (default)
 - Optional live mode via ccxt (exchange API required)
"""

import time
import math
import logging
from dataclasses import dataclass
from typing import Optional, Dict, Any, List
import numpy as np
import pandas as pd
import ccxt
from dotenv import load_dotenv
import os

# Load .env for API keys if present
load_dotenv()

# ---- CONFIG ----
@dataclass
class Config:
    exchange_id: str = "binance"            # change as needed
    symbol: str = "BTC/USDT"               # trading pair
    timeframe: str = "1h"                  # timeframe for candles
    limit: int = 500                       # history candles to fetch
    paper: bool = True                     # True = paper trading (default)
    live_order_type: str = "market"        # market or limit
    base_order_size_usd: float = 50.0      # USD size per trade (paper mode uses this)
    max_positions: int = 1                 # max concurrent positions
    stop_loss_pct: float = 0.03            # 3% stop loss by default
    take_profit_pct: Optional[float] = None# optional take profit
    sma_fast: int = 50
    sma_slow: int = 200
    verbose: bool = True

cfg = Config()

# ---- Logging ----
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s: %(message)s')
logger = logging.getLogger("ai_trader")
if not cfg.verbose:
    logger.setLevel(logging.WARNING)

# ---- Exchange helper ----
def make_exchange(cfg: Config):
    ex_class = getattr(ccxt, cfg.exchange_id)
    kwargs: Dict[str, Any] = {'enableRateLimit': True}
    # Fill API keys from environment only if present AND NOT in paper mode
    api_key = os.getenv("API_KEY")
    secret = os.getenv("API_SECRET")
    if api_key and secret and not cfg.paper:
        kwargs['apiKey'] = api_key
        kwargs['secret'] = secret
    exchange = ex_class(kwargs)
    # set sandbox if supported? For Binance: exchange.set_sandbox_mode(True)
    return exchange

# ---- Data fetching ----
def fetch_ohlcv(exchange, symbol, timeframe, limit=500) -> pd.DataFrame:
    # ccxt returns [ts, open, high, low, close, volume]
    raw = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
    df = pd.DataFrame(raw, columns=['timestamp','open','high','low','close','volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    return df

# ---- Strategy: SMA crossover ----
def add_indicators(df: pd.DataFrame, cfg: Config):
    df['sma_fast'] = df['close'].rolling(cfg.sma_fast).mean()
    df['sma_slow'] = df['close'].rolling(cfg.sma_slow).mean()
    return df

def signal_from_df(df: pd.DataFrame) -> str:
    """
    Returns 'buy', 'sell', or 'hold' based on last two bars cross.
    """
    if len(df) < cfg.sma_slow + 2:
        return "hold"
    last = df.iloc[-1]
    prev = df.iloc[-2]
    # cross up -> buy, cross down -> sell
    cross_up = (prev['sma_fast'] <= prev['sma_slow']) and (last['sma_fast'] > last['sma_slow'])
    cross_down = (prev['sma_fast'] >= prev['sma_slow']) and (last['sma_fast'] < last['sma_slow'])
    if cross_up:
        return "buy"
    if cross_down:
        return "sell"
    return "hold"

# ---- Risk manager ----
def position_size_usd(cfg: Config, price: float) -> float:
    """Simple fixed-size; could be replaced with volatility sizing"""
    return cfg.base_order_size_usd

# ---- Executor (paper/live) ----
class Executor:
    def __init__(self, exchange, cfg: Config):
        self.exchange = exchange
        self.cfg = cfg
        self.paper_account = {"USD": 10000.0, "positions": {}}  # simple paper account
        # NOTE: For realistic backtests you'd want OHLC-level fills etc.

    def get_balances(self):
        if self.cfg.paper:
            return self.paper_account
        else:
            return self.exchange.fetch_balance()

    def place_order(self, side: str, amount_base: float, price: Optional[float]=None):
        """
        side: 'buy' or 'sell'
        amount_base: amount of base currency (e.g., BTC)
        """
        if self.cfg.paper:
            return self._place_order_paper(side, amount_base, price)
        else:
            return self._place_order_live(side, amount_base, price)

    def _place_order_paper(self, side, amount_base, price):
        # price is optional, use last market price if None
        ticker = self.exchange.fetch_ticker(cfg.symbol)
        trade_price = price or ticker['last']
        quote_amount = amount_base * trade_price
        if side == 'buy':
            if self.paper_account['USD'] < quote_amount:
                raise RuntimeError("Not enough USD in paper account")
            self.paper_account['USD'] -= quote_amount
            # add to positions
            pos = self.paper_account['positions'].get(cfg.symbol, {"base":0.0, "avg_price":0.0})
            total_base = pos['base'] + amount_base
            pos['avg_price'] = ((pos['avg_price'] * pos['base']) + trade_price * amount_base) / (total_base if total_base>0 else 1)
            pos['base'] = total_base
            self.paper_account['positions'][cfg.symbol] = pos
            logger.info(f"[PAPER] Bought {amount_base} {cfg.symbol.split('/')[0]} at {trade_price:.2f} USD")
            return {"status":"filled","price":trade_price,"amount":amount_base,"side":side}
        else:
            # sell
            pos = self.paper_account['positions'].get(cfg.symbol, {"base":0.0, "avg_price":0.0})
            if pos['base'] < amount_base:
                raise RuntimeError("Not enough base currency in paper account")
            pos['base'] -= amount_base
            quote = amount_base * trade_price
            self.paper_account['USD'] += quote
            logger.info(f"[PAPER] Sold {amount_base} {cfg.symbol.split('/')[0]} at {trade_price:.2f} USD")
            return {"status":"filled","price":trade_price,"amount":amount_base,"side":side}

    def _place_order_live(self, side, amount_base, price):
        # Be VERY careful. This will send orders to exchange.
        symbol = cfg.symbol
        if cfg.live_order_type == "market":
            order = self.exchange.create_market_order(symbol, side, amount_base)
        else:
            if price is None:
                raise ValueError("Limit order requires a price")
            order = self.exchange.create_limit_order(symbol, side, amount_base, price)
        logger.info(f"[LIVE] Sent order: {order}")
        return order

# ---- Simple backtest ----
def backtest(df: pd.DataFrame, cfg: Config):
    df = add_indicators(df.copy(), cfg)
    cash = 10000.0
    base = 0.0
    equity_curve = []
    entry_price = None

    for i in range(len(df)):
        if i < cfg.sma_slow: 
            equity_curve.append(cash + base * df['close'].iloc[i])
            continue
        window = df.iloc[:i+1]
        sig = signal_from_df(window)
        price = df['close'].iloc[i]
        if sig == "buy" and base == 0.0:
            usd_to_spend = cfg.base_order_size_usd
            amount = usd_to_spend / price
            if cash >= usd_to_spend:
                cash -= usd_to_spend
                base += amount
                entry_price = price
        elif sig == "sell" and base > 0.0:
            cash += base * price
            base = 0.0
            entry_price = None
        # stop loss check
        if entry_price and base > 0:
            if price <= entry_price * (1 - cfg.stop_loss_pct):
                # stop out
                cash += base * price
                base = 0.0
                entry_price = None
        equity_curve.append(cash + base * price)

    res = pd.DataFrame({
        "timestamp": df.index,
        "close": df['close'],
        "equity": equity_curve
    }).set_index('timestamp')
    return res

# ---- Main loop (polling) ----
def main_loop(cfg: Config):
    exchange = make_exchange(cfg)
    executor = Executor(exchange, cfg)
    logger.info("Starting main loop. PAPER MODE = %s", cfg.paper)

    while True:
        try:
            df = fetch_ohlcv(exchange, cfg.symbol, cfg.timeframe, limit=cfg.limit)
            df = add_indicators(df, cfg)
            sig = signal_from_df(df)
            last_price = df['close'].iloc[-1]
            logger.info("Signal: %s at price %.2f", sig, last_price)

            if sig == "buy":
                usd = position_size_usd(cfg, last_price)
                amount = usd / last_price
                # create order (paper by default)
                try:
                    executor.place_order("buy", amount, price=last_price if not cfg.paper else None)
                except Exception as e:
                    logger.error("Order failed: %s", e)

            elif sig == "sell":
                # determine base amount in paper account or in exchange (live)
                if cfg.paper:
                    pos = executor.paper_account['positions'].get(cfg.symbol, {"base":0.0})
                    amount = pos['base']
                    if amount > 0:
                        executor.place_order("sell", amount, price=last_price if not cfg.paper else None)
                else:
                    # for live, check balance from API then sell
                    bal = exchange.fetch_balance()
                    base_sym = cfg.symbol.split('/')[0]
                    amount = bal.get(base_sym, {}).get('free', 0)
                    if amount > 0:
                        executor.place_order("sell", amount)

            # wait until next candle - naive sleep (tweak if you want near-real-time)
            # For live trading consider websocket streams for lower latency
            sleep_seconds = 60
            logger.info("Sleeping %d s until next poll...", sleep_seconds)
            time.sleep(sleep_seconds)

        except Exception as ex:
            logger.exception("Error in main loop: %s", ex)
            time.sleep(10)

# ---- Usage helpers ----
def run_backtest_and_report(cfg: Config):
    exchange = make_exchange(cfg)
    df = fetch_ohlcv(exchange, cfg.symbol, cfg.timeframe, limit=cfg.limit)
    res = backtest(df, cfg)
    # Simple metrics
    initial = res['equity'].iloc[0]
    final = res['equity'].iloc[-1]
    ret = (final - initial) / initial
    max_dd = (res['equity'].cummax() - res['equity']).max() / res['equity'].cummax().max()
    logger.info("Backtest: start=%s end=%s ret=%.2f%% max_dd=%.2f%%", initial, final, ret*100, max_dd*100)
    return res

# ---- If run as script ----
if __name__ == "__main__":
    # Quick CLI-like behavior by env vars
    MODE = os.getenv("MODE", "run")   # "run" or "backtest"
    if MODE == "backtest":
        logger.info("Running backtest...")
        eq = run_backtest_and_report(cfg)
        print(eq.tail(10))
    else:
        logger.info("Starting live/paper run loop. To backtest set MODE=backtest.")
        main_loop(cfg)